# Gustavo

I like computers when they are *totally honest* about what theyâ€™re doing.
If something works, I want to know **why** it works â€” preferably down to the bit level.

## Current Focus

Right now, most of my curiosity lives close to the metal:

* **Low-level programming** with a strong focus on **x86_64 Assembly** and **C**
* **Operating system internals** â€” boot process, memory management, paging, segmentation
* Building things from scratch to understand them properly (file systems, kernels, loaders)
* Learning by reading specs, source code, and old documentation (classics)

I enjoy systems that are small, understandable, and composable.
Complexity should be *earned*, not accidental.
And this is not only about systems.

## Environment & Tools

* **Arch Linux** as my daily driver
* Minimalist workflow (dwm, terminal-first, keyboard-centric)
* Strong appreciation for Unix philosophy and the *suckless* mindset
* Text over tools, clarity over convenience

## How I Learn

* Reading original documentation and standards (Intel manuals, POSIX, ELF specs)
* Reimplementing concepts instead of abstracting them away too early
* Treating programming as both engineering *and* archaeology

I believe understanding grows faster when you rebuild the foundations yourself.

## What Iâ€™m Working Toward

* Becoming deeply fluent in systems programming
* Writing software that is simple, predictable, and long-lived
* Communicating complex technical ideas clearly â€” especially in English

## Side Interests

* Computer architecture and history
* How abstractions leak â€” and when thatâ€™s a feature
* Cinema and storytelling (especially sciâ€‘fi, I like them ðŸ˜Š)

---

> "The best abstractions are the ones you could remove if needed."

If something here resonates, feel free to explore and start a conversation.
