# Gustavo

I like computers when they are *totally honest* about what they’re doing.
If something works, I want to know why it works — preferably down to the bit level.

## Current Focus

Right now, most of my curiosity lives close to the metal:

* **Low-level programming** with a strong focus on **x86_64 Assembly** and **C**
* **Operating system internals** — boot process, memory management, paging, segmentation
* Building things from scratch to understand them properly (file systems, kernels, loaders)
* Learning by reading specs, source code, and old documentations

I enjoy systems that are small, understandable, and composable.

## Environment & Tools

* **Arch Linux** as my daily driver
* Minimalist workflow (dwm, terminal-first, keyboard-centric)
* Strong appreciation for Unix philosophy and the Suckless mindset
* Text over tools, clarity over convenience

## How I Learn

* Reading original documentation and standards (Intel manuals, POSIX, ELF specs)
* Reimplementing concepts instead of abstracting them away too early
* Treating programming as both engineering and archaeology
* Sometimes, by doing

## What I’m Working Toward

* Becoming deeply fluent in systems programming
* Writing software that is simple, predictable, and long-lived
* Communicating complex technical ideas clearly — especially in English

## Side Interests

* Computer architecture and history
* How abstractions leak — and when that’s a feature
* Cinema & Star Wars itself

---

> "The best abstractions are the ones you could remove if needed."

If something here resonates, feel free to explore and start a conversation.
